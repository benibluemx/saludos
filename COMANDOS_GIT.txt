/****
CREACION DE UN REPOSITORIO
****/

Paso 1 - Git Init

Para almacenar un directorio bajo control de versiones, se necesita crear un repositorio. 
Con GIT se inicializa un repositorio en el primer nivel del directorio de un proyecto.
Aprovecharemos esta práctica para introducir los settings iniciales de Git.


Paso 2 - Git Status

Cuando un directorio es parte de un repositorio, se le llama Working Directory. Un directorio de trabajo o working directory contiene la última versión descargada desde 
el repositorio junto con cualquier cambio que tenga que ser aprobado. Al estar trabajando en un proyecto, todos los cambios se realizan en el working directory.

Podemos ver los cuales de los ficheros han cambiado en el working directory y qué cambios van a ser aprobados (committed) al repositorio usando el comando git status.

La salida de este comando recibe el nombre de “working tree status“.


Paso 3 - Git Add

Para guardar, o aprobar (commit) ficheros en nuestro repositorio GIT, primero se necesita añadirlos al stagging area (área de preparación). 
Git tiene tres áreas:
 un working directory,
 un staging area,
 y el propio repositorio en sí (directorio oculto .git). 
Los usuarios “mueven” (también se refiere a ello como “promueven/promote”) cambios desde el working directory al área de preparación o staging área, 
antes de aprobarlos/commit hacia el repositorio.

Uno de los enfoques clave con Git consiste en que los commits están concentrados, son pequeños y frecuentes. 
El área de preparación/staging area ayuda a mantener este flujo de trabajo permitiendo promover solo ciertos ficheros 
cada vez en lugar de obligar a subir todos los cambios del directorio de trabajo.

Paso 4 - Git Commit

Una vez que el fichero ha sido añadido a la satging area, se necesita que sea aprobado (commited) hacia el repositorio. 
El comando git commit -m “commit message” 
mueve ficheros desde la staging area o área de preparación hacia el repositorio, y almacena fecha/hora, autor y un mensaje de aprobación que puede usarse para agregar 
información de contexto adicional a los cambios, como por ejemplo un identificador de error, o número identificador de bug.

Solo los cambios añadidos a la staging area serán aprobados/commited ; cualquier fichero en el working directory que no haya sido añadido con git add 
(es decir, cualquier fichero no staged), no se incluirá en el commit de cambios.

Paso 5 - Git Ignore

A veces, hay ficheros o directorios que nunca querremos aprobar aunque estén en nuestro working directory , como por ejemplo configuración local de desarrollo.
 Para ignorar estos ficheros, usamos un fichero .gitignore lal raíz del repositorio.

El fichero .gitignore te permite definir máscaras o wildcards para los ficheros que deseamos ignorar; 
por ejemplo, el wildcard “.tmp” permitiría ignorar a todos los ficheros con extensión tmp* .

Cualquier fichero que corresponda a un wildcard no será mostrado en la salida de un git status y por lo tanto será ignorado cuando lancemos un comando git add.


/****
APROBANDO CAMBIOS
****/

Paso 1 - Git Status

Tal y como se ha discutido en la lección previa, git status nos permite visualizar los cambios en el working directory y en la staging area comparando con el repositorio.
Dado que el repositorio actual en el que lanzamos git status muestra que un cambio hecho en nuestro working directory y tenemos en él un fichero previamente aprobado 
(por ejemplo hello-world.js), si lo modificamos, y a la vez creamos otro fichero, commited.js, 
que ni siquiera ha sido movido aún a staging area, ¿qué nos mostrará?

Paso 2 - Git Diff

El comando git diff permite comparar cambios en el working directory contra una versión previamente aprobada. Por defecto, 
el comando compara el working directory y el commit que llamamos HEAD (el más reciente).

Si se desea comparar el working directory contra una versión más antigua, entonces podemos proporcionar su hash_id como parámetro en la llamada al comando; así: git diff .

Comparar contra commits mostrará los cambios en todos los ficheros que se hayan modificado. Si deseamos comparar los cambios en un único fichero, podemos pasar su nombre como parámetro:

 git diff committed.js
 
/****
REVISANDO LOGS
****/

git logs --online

/****
MODIFICAR FILE DESDE TERMIMAL GIT
****/

vi nombreArchivo

salir de esa terminal ctrl+shift +z

/****
ELIMINAR UN ARCHIVO
****/
rm nombreArchivo

/****
RECUPERAR ESE ARCHIVO 
****/

git checkout nombreArchivoARecuperar

/****
LISTAR ARCHIVOS
****/

ls -la


/****
GIT REMOTE
****/

Paso 1 - Git Remote
Los repositorios remotos permiten compartir cambios desde o hacia nuestro repositorio. Las ubicaciones remotas son generalmente servidores locales,
 una máquina de un equipo de trabajo o bien un almacén de repositorios en la nube como GitLab o Github.

Los repositorios remotos se añaden usando el comando git remote con un nombre amigable y una ubicación remota; normalmente una conexión HTTPS o SSH 
(para esto último no hace falta software específico como GitLab).

Ejemplo: https://github.com/sharkdp/bat

El nombre amigable permite referenciar la localización en otros comandos. Nuestro repositorio local puede referenciar múltiples repositorios remotos, 
dependiendo de nuestras necesidades.


Paso 2 - Git Push
Cuando estamos listos para compartir nuestros commits, es necesario hacer un push de ellos a un repositorio remoto usando git push.
 Un flujo de trabajo habitual de GIT sería llevar a cabo múltiples commits pequeños conforme vamos finalizando tareas, y hacerles un push a un repositorio remoto en hitos relevantes, como cuando finalizamos un bloque de trabajo, de manera que aseguramos la sincronización del código dentro de un equipo.

El comando git push se acompaña de dos parámetros. El primero es el nombre amigable del repositorio remoto (normalmente origin). El segundo es el nombre de la rama (normalmente, rama master). Por defecto, todos los repositorios tienen una rama master donde se trabaja con el código.

echo "# trial" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/benibluemx/trial.git
git push -u origin main


Paso 3 - Git Pull
El comando git push permite subir los cambios a un repositorio remoto, mientras que git pull funciona de forma inversa. El comando git pull permite sincronizar cambios de un repositorio remoto en nuestra versión local.

Los cambios desde el repositorio remoto son automáticamente fusionados (merge) en la rama en la que estamos trabajando en el momento de lanzar el comando.
                

/****
CAMBIARSE ENTRE RAMAS REMOTAS
****/

$ git remote set-url origin https://git-repo/new-repository.git


$ git remote -v


 
 
